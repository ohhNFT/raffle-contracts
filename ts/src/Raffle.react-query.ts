/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.25.2.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Uint128, Decimal, InstantiateMsg, Coin, ExecuteMsg, AssetInfo, GatingOptionsMsg, Timestamp, Uint64, Binary, HexBinary, Cw721Coin, Sg721Token, RaffleOptionsMsg, Cw20Coin, Cw721ReceiveMsg, NoisCallback, QueryMsg, QueryFilters, Addr, GatingOptions, RaffleState, AllRafflesResponse, RaffleResponse, RaffleInfo, RaffleOptions, Cw20CoinVerified, ArrayOfString, ConfigResponse, Locks, Uint32 } from "./Raffle.types";
import { RaffleQueryClient, RaffleClient } from "./Raffle.client";
export const raffleQueryKeys = {
  contract: ([{
    contract: "raffle"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...raffleQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...raffleQueryKeys.address(contractAddress)[0],
    method: "config",
    args
  }] as const),
  raffleInfo: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...raffleQueryKeys.address(contractAddress)[0],
    method: "raffle_info",
    args
  }] as const),
  allRaffles: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...raffleQueryKeys.address(contractAddress)[0],
    method: "all_raffles",
    args
  }] as const),
  allTickets: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...raffleQueryKeys.address(contractAddress)[0],
    method: "all_tickets",
    args
  }] as const),
  ticketCount: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...raffleQueryKeys.address(contractAddress)[0],
    method: "ticket_count",
    args
  }] as const)
};
export const raffleQueries = {
  config: <TData = ConfigResponse,>({
    client,
    options
  }: RaffleConfigQuery<TData>): UseQueryOptions<ConfigResponse, Error, TData> => ({
    queryKey: raffleQueryKeys.config(client?.contractAddress),
    queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  raffleInfo: <TData = RaffleResponse,>({
    client,
    args,
    options
  }: RaffleRaffleInfoQuery<TData>): UseQueryOptions<RaffleResponse, Error, TData> => ({
    queryKey: raffleQueryKeys.raffleInfo(client?.contractAddress, args),
    queryFn: () => client ? client.raffleInfo({
      raffleId: args.raffleId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  allRaffles: <TData = AllRafflesResponse,>({
    client,
    args,
    options
  }: RaffleAllRafflesQuery<TData>): UseQueryOptions<AllRafflesResponse, Error, TData> => ({
    queryKey: raffleQueryKeys.allRaffles(client?.contractAddress, args),
    queryFn: () => client ? client.allRaffles({
      filters: args.filters,
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  allTickets: <TData = ArrayOfString,>({
    client,
    args,
    options
  }: RaffleAllTicketsQuery<TData>): UseQueryOptions<ArrayOfString, Error, TData> => ({
    queryKey: raffleQueryKeys.allTickets(client?.contractAddress, args),
    queryFn: () => client ? client.allTickets({
      limit: args.limit,
      raffleId: args.raffleId,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  ticketCount: <TData = Uint32,>({
    client,
    args,
    options
  }: RaffleTicketCountQuery<TData>): UseQueryOptions<Uint32, Error, TData> => ({
    queryKey: raffleQueryKeys.ticketCount(client?.contractAddress, args),
    queryFn: () => client ? client.ticketCount({
      owner: args.owner,
      raffleId: args.raffleId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface RaffleReactQuery<TResponse, TData = TResponse> {
  client: RaffleQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface RaffleTicketCountQuery<TData> extends RaffleReactQuery<Uint32, TData> {
  args: {
    owner: string;
    raffleId: number;
  };
}
export function useRaffleTicketCountQuery<TData = Uint32>({
  client,
  args,
  options
}: RaffleTicketCountQuery<TData>) {
  return useQuery<Uint32, Error, TData>(raffleQueryKeys.ticketCount(client?.contractAddress, args), () => client ? client.ticketCount({
    owner: args.owner,
    raffleId: args.raffleId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface RaffleAllTicketsQuery<TData> extends RaffleReactQuery<ArrayOfString, TData> {
  args: {
    limit?: number;
    raffleId: number;
    startAfter?: number;
  };
}
export function useRaffleAllTicketsQuery<TData = ArrayOfString>({
  client,
  args,
  options
}: RaffleAllTicketsQuery<TData>) {
  return useQuery<ArrayOfString, Error, TData>(raffleQueryKeys.allTickets(client?.contractAddress, args), () => client ? client.allTickets({
    limit: args.limit,
    raffleId: args.raffleId,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface RaffleAllRafflesQuery<TData> extends RaffleReactQuery<AllRafflesResponse, TData> {
  args: {
    filters?: QueryFilters;
    limit?: number;
    startAfter?: number;
  };
}
export function useRaffleAllRafflesQuery<TData = AllRafflesResponse>({
  client,
  args,
  options
}: RaffleAllRafflesQuery<TData>) {
  return useQuery<AllRafflesResponse, Error, TData>(raffleQueryKeys.allRaffles(client?.contractAddress, args), () => client ? client.allRaffles({
    filters: args.filters,
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface RaffleRaffleInfoQuery<TData> extends RaffleReactQuery<RaffleResponse, TData> {
  args: {
    raffleId: number;
  };
}
export function useRaffleRaffleInfoQuery<TData = RaffleResponse>({
  client,
  args,
  options
}: RaffleRaffleInfoQuery<TData>) {
  return useQuery<RaffleResponse, Error, TData>(raffleQueryKeys.raffleInfo(client?.contractAddress, args), () => client ? client.raffleInfo({
    raffleId: args.raffleId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface RaffleConfigQuery<TData> extends RaffleReactQuery<ConfigResponse, TData> {}
export function useRaffleConfigQuery<TData = ConfigResponse>({
  client,
  options
}: RaffleConfigQuery<TData>) {
  return useQuery<ConfigResponse, Error, TData>(raffleQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface RaffleToggleLockMutation {
  client: RaffleClient;
  msg: {
    lock: boolean;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useRaffleToggleLockMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, RaffleToggleLockMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, RaffleToggleLockMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.toggleLock(msg, fee, memo, funds), options);
}
export interface RaffleUpdateRandomnessMutation {
  client: RaffleClient;
  msg: {
    raffleId: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useRaffleUpdateRandomnessMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, RaffleUpdateRandomnessMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, RaffleUpdateRandomnessMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateRandomness(msg, fee, memo, funds), options);
}
export interface RaffleNoisReceiveMutation {
  client: RaffleClient;
  msg: {
    callback: NoisCallback;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useRaffleNoisReceiveMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, RaffleNoisReceiveMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, RaffleNoisReceiveMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.noisReceive(msg, fee, memo, funds), options);
}
export interface RaffleReceiveMutation {
  client: RaffleClient;
  msg: {
    msg: Binary;
    sender: string;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useRaffleReceiveMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, RaffleReceiveMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, RaffleReceiveMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.receive(msg, fee, memo, funds), options);
}
export interface RaffleBuyTicketMutation {
  client: RaffleClient;
  msg: {
    onBehalfOf?: string;
    raffleId: number;
    sentAssets: AssetInfo;
    ticketCount: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useRaffleBuyTicketMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, RaffleBuyTicketMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, RaffleBuyTicketMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.buyTicket(msg, fee, memo, funds), options);
}
export interface RaffleModifyRaffleMutation {
  client: RaffleClient;
  msg: {
    raffleId: number;
    raffleOptions: RaffleOptionsMsg;
    raffleTicketPrice?: AssetInfo;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useRaffleModifyRaffleMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, RaffleModifyRaffleMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, RaffleModifyRaffleMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.modifyRaffle(msg, fee, memo, funds), options);
}
export interface RaffleUpdateConfigMutation {
  client: RaffleClient;
  msg: {
    creationCoins?: Coin[];
    feeAddr?: string;
    maxTicketsPerRaffle?: number;
    minimumRaffleDuration?: number;
    name?: string;
    noisProxyAddr?: string;
    noisProxyCoin?: Coin;
    owner?: string;
    raffleFee?: Decimal;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useRaffleUpdateConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, RaffleUpdateConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, RaffleUpdateConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateConfig(msg, fee, memo, funds), options);
}
export interface RaffleClaimRaffleMutation {
  client: RaffleClient;
  msg: {
    raffleId: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useRaffleClaimRaffleMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, RaffleClaimRaffleMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, RaffleClaimRaffleMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.claimRaffle(msg, fee, memo, funds), options);
}
export interface RaffleCancelRaffleMutation {
  client: RaffleClient;
  msg: {
    raffleId: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useRaffleCancelRaffleMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, RaffleCancelRaffleMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, RaffleCancelRaffleMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.cancelRaffle(msg, fee, memo, funds), options);
}
export interface RaffleCreateRaffleMutation {
  client: RaffleClient;
  msg: {
    assets: AssetInfo[];
    owner?: string;
    raffleOptions: RaffleOptionsMsg;
    raffleTicketPrice: AssetInfo;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useRaffleCreateRaffleMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, RaffleCreateRaffleMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, RaffleCreateRaffleMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.createRaffle(msg, fee, memo, funds), options);
}